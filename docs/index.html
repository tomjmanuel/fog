<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bay Area Clouds and Fog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark;
    }

    body {
      margin: 0;
      background: #05060a;
      color: #f5f5f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 1rem;
      box-sizing: border-box;
      gap: 1rem;
    }

    .stage {
      position: relative;
      aspect-ratio: 1500 / 1970;
      width: min(calc(100vw - 2rem), calc((100vh - 4rem) * 1500 / 1970));
      max-height: calc(100vh - 4rem);
      background: radial-gradient(circle at top, #1c2333, #05060a 60%);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.6);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .stage img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      image-rendering: crisp-edges;
      image-rendering: pixelated;
      filter: drop-shadow(0 0 15px rgba(0, 0, 0, 0.8));
    }

    .frame-layer {
      position: absolute;
      inset: 0;
      opacity: 0;
    }

    .frame-layer.active {
      opacity: 1;
    }

    .frame-meta {
      width: min(calc(100vw - 2rem), 700px);
      font-size: 0.85rem;
      letter-spacing: 0.02em;
      opacity: 0.8;
    }
    .controls {
      display: flex;
      justify-content: flex-start;
      width: min(calc(100vw - 2rem), 700px);
    }

    .controls button {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.04);
      color: inherit;
      padding: 0.35rem 1.2rem;
      font: inherit;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      font-size: 0.8rem;
    }

    .controls button:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .data-credit {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .data-credit a {
      color: inherit;
    }
  </style>
</head>
<body>
  <div class="stage">
    <img class="frame-layer active" alt="Fog render sequence" />
    <img class="frame-layer" alt="" aria-hidden="true" />
  </div>

  <div class="frame-meta" id="frame-count">Loading frames…</div>

  <div class="controls">
    <button id="latest-btn" type="button">Latest image</button>
  </div>

  <div class="data-credit">
    Data provided by
    <a href="https://weather.ndc.nasa.gov/goes/" target="_blank" rel="noreferrer">
      NASA GOES-West
    </a>
  </div>

  <script>
    console.log("fog page script starting");

    window.addEventListener("error", (e) => {
      console.error("Global error:", e.message);
    });

    // === CONFIG ===
    const BUCKET = "fog-app-renders";
    const REGION = "us-west-1";
    const LOOP_FPS = 2;
    const LOOP_INTERVAL_MS = 1000 / LOOP_FPS;

    // Hardcoded list URL for now
    const LIST_URL =
      "https://fog-app-renders.s3.us-west-1.amazonaws.com/?list-type=2&prefix=daily/";

    let frames = [];
    let currentIndex = 0;
    let loopTimeoutId = null;
    let isPlaying = false;
    let lockedOnLatest = false;

    const imgLayers = Array.from(document.querySelectorAll(".frame-layer"));
    let activeLayerIndex = 0;
    const frameCountEl = document.getElementById("frame-count");
    const latestBtn = document.getElementById("latest-btn");

    function parseTimestampFromKey(key) {
      const filename = key.split("/").pop();
      const match = filename.match(
        /^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})Z/
      );
      console.log("parseTimestampFromKey:", { key, filename, match });
      if (!match) return null;
      const [, year, month, day, hour, minute, second] = match;
      const date = new Date(
        Date.UTC(
          Number(year),
          Number(month) - 1,
          Number(day),
          Number(hour),
          Number(minute),
          Number(second)
        )
      );
      return date;
    }

    function formatTimestampForOverlay(date) {
      if (!date) return "Unknown time";
      const opts = {
        year: "numeric",
        month: "short",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        timeZone: "America/Los_Angeles",
        timeZoneName: "short"
      };
      return date.toLocaleString("en-US", opts);
    }

    function updateFrameCount() {
      if (frames.length === 0) {
        frameCountEl.textContent = "No frames available";
        return;
      }
      const currentFrame = frames[currentIndex];
      const timestampLabel = currentFrame?.label ? ` — ${currentFrame.label}` : "";
      frameCountEl.textContent = `${frames.length} captures${timestampLabel}`;
    }

    function preloadImage(src) {
      return new Promise((resolve) => {
        const img = new Image();
        const finalize = () => {
          img.onload = null;
          img.onerror = null;
          resolve();
        };
        img.onload = finalize;
        img.onerror = finalize;
        img.src = src;
        if (img.complete) {
          finalize();
        }
      });
    }

    async function showFrame(index) {
      if (!frames.length) return;
      const frame = frames[index];
      if (!frame) return;
      const nextLayerIndex = 1 - activeLayerIndex;
      const nextLayer = imgLayers[nextLayerIndex];
      const src = frame.url;
      if (nextLayer.dataset.src !== src) {
        try {
          await preloadImage(src);
        } catch (err) {
          console.warn("preload failed", err);
        }
        nextLayer.src = src;
        nextLayer.dataset.src = src;
      }
      imgLayers[activeLayerIndex].classList.remove("active");
      nextLayer.classList.add("active");
      activeLayerIndex = nextLayerIndex;
      updateFrameCount();
    }

    function scheduleNextFrame() {
      if (!isPlaying || !frames.length) return;
      clearTimeout(loopTimeoutId);
      loopTimeoutId = setTimeout(async () => {
        if (!isPlaying || !frames.length) return;
        currentIndex = (currentIndex + 1) % frames.length;
        await showFrame(currentIndex);
        scheduleNextFrame();
      }, LOOP_INTERVAL_MS);
    }

    async function startLoop() {
      if (!frames.length) return;
      clearTimeout(loopTimeoutId);
      isPlaying = true;
      lockedOnLatest = false;
      latestBtn.textContent = "Latest image";
      await showFrame(currentIndex);
      scheduleNextFrame();
    }

    function stopLoop() {
      isPlaying = false;
      clearTimeout(loopTimeoutId);
      loopTimeoutId = null;
    }

    async function fetchFrames() {
      console.log("fetchFrames() called");
      frameCountEl.textContent = "Loading frames…";
      try {
        const resp = await fetch(LIST_URL);
        console.log("List response status:", resp.status);
        const xmlText = await resp.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlText, "application/xml");

        const contents = Array.from(xml.getElementsByTagName("Contents"));
        const items = contents
          .map((node) => {
            const key = node.getElementsByTagName("Key")[0].textContent;
            return key;
          })
          .filter((key) => key && key.endsWith(".png"));

        console.log("Contents length:", contents.length);
        console.log("PNG items:", items);

        const newFrames = items
          .map((key) => {
            const ts = parseTimestampFromKey(key);
            const segments = key.split("/").map(encodeURIComponent);
            const url = `https://${BUCKET}.s3.${REGION}.amazonaws.com/${segments.join(
              "/"
            )}`;
            return {
              key,
              url,
              timestampUtc: ts,
              label: ts ? formatTimestampForOverlay(ts) : key
            };
          })
          .filter((f) => !!f.timestampUtc);

        console.log("Parsed frames:", newFrames);

        newFrames.sort((a, b) => a.timestampUtc - b.timestampUtc);

        const previousKey =
          frames.length && frames[currentIndex] ? frames[currentIndex].key : null;

        frames = newFrames;
        if (!frames.length) {
          currentIndex = 0;
        } else if (lockedOnLatest) {
          currentIndex = frames.length - 1;
        } else if (previousKey) {
          const matchIdx = frames.findIndex((frame) => frame.key === previousKey);
          currentIndex = matchIdx >= 0 ? matchIdx : 0;
        } else {
          currentIndex = 0;
        }
        updateFrameCount();

        if (frames.length > 0) {
          if (isPlaying) {
            startLoop();
          } else {
            showFrame(currentIndex);
          }
        }
      } catch (err) {
        console.error("Error in fetchFrames:", err);
        frameCountEl.textContent = "Error loading frames";
      }
    }

    latestBtn.addEventListener("click", async () => {
      if (!frames.length) return;
      if (!lockedOnLatest) {
        stopLoop();
        currentIndex = frames.length - 1;
        await showFrame(currentIndex);
        lockedOnLatest = true;
        latestBtn.textContent = "Resume loop";
      } else {
        startLoop();
      }
    });

    (async function init() {
      console.log("init() starting");
      await fetchFrames();
      if (frames.length) {
        currentIndex = 0;
        startLoop();
      }
      setInterval(fetchFrames, 60000);
    })();
  </script>
</body>
</html>
